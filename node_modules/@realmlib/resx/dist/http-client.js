"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const https = require("https");
const url = require("url");
const zlib = require("zlib");
/**
 * The HTTP headers to include in each request.
 */
exports.REQUEST_HEADERS = {
    'Cache-Control': 'max-age=0',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
    'Accept-Encoding': 'gzip, deflate',
    'Connection': 'keep-alive',
};
function get(path, stream) {
    if (typeof path !== 'string') {
        return Promise.reject(new TypeError(`Parameter "path" should be a string, not ${typeof path}`));
    }
    const endpoint = url.parse(path);
    const opts = {
        host: endpoint.host,
        path: endpoint.path,
        headers: exports.REQUEST_HEADERS,
    };
    return new Promise((resolve, reject) => {
        https.get(opts, resolve).once('error', reject);
    }).then((msg) => {
        return handleResponse(msg, stream);
    });
}
exports.get = get;
function handleResponse(msg, writeStream) {
    return new Promise((resolve, reject) => {
        let stream = msg;
        if (msg.headers['content-encoding'] === 'gzip') {
            const gunzip = zlib.createGunzip();
            stream = msg.pipe(gunzip);
        }
        if (writeStream) {
            stream.pipe(writeStream).once('close', resolve).once('error', reject);
        }
        else {
            let data = [];
            stream.on('data', (chunk) => {
                data.push(chunk);
            });
            stream.once('end', () => {
                data = Buffer.concat(data);
                resolve(data);
            });
            stream.once('error', reject);
        }
    });
}
